--set opertion : union, union all, minus, intersect
--union : 각각의 쿼리 결과를 하나로 합친다. 중복된 행을 제거한다.
--부서 번호가 D5인 직원을 조회
--6
SELECT *
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5';

--급여가 300만원 이상인 직원들을 조회
--8
SELECT *
FROM EMPLOYEE
WHERE 3000000 <= SALARY;

SELECT EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5'
UNION
SELECT EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE 3000000 <= SALARY;


--UNION ALL : 각각의 쿼리 결과를 합칠때, 중복된 행을 출력한다.
SELECT EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5'
UNION ALL
SELECT EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE 3000000 <= SALARY;

--1. 전화번호가 NULL인 직원들의 이름, 전화번호, 부서번호, 급여
--2. 부서번호가 D8인 직원들의 정보(이름, 전화번호, 부서번호, 급여)
--3. 급여가 500만원 이하인 직원들의 정보(이름, 전화번호, 부서번호, 급여)
--UNION
SELECT EMP_NAME, PHONE, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE PHONE IS NULL
UNION
SELECT EMP_NAME, PHONE, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE = 'D8'
UNION
SELECT EMP_NAME, PHONE, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY <= 5000000;


--UNION ALL
SELECT EMP_NAME, PHONE, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE PHONE IS NULL
UNION ALL
SELECT EMP_NAME, PHONE, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE = 'D8'
UNION ALL
SELECT EMP_NAME, PHONE, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY <= 5000000;

--INTERSECT : 집합에서의 교집합,
--                     여러개의 SELECT에서 공통적인 ROW만을 출력
--위에 있는 SELECT와 아래 있는 SELECT문의 결과 중 겹치는 항목들을 출력
SELECT EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5'
INTERSECT
SELECT EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE 3000000 <= SALARY;

SELECT EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5'
INTERSECT
SELECT EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE 3000000 <= SALARY
INTERSECT
SELECT EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE EMP_NAME = '대북혼';

--MINUS : 집합에서의 차집합과 같은 개념이다
--              처음에 조회된 항목을 기준으로 아래서 조회된 항목과 겹치는 부분을 제거 한 후 출력
SELECT EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5'
MINUS
SELECT EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE 3000000 <= SALARY;



SELECT EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE 3000000 <= SALARY
MINUS
SELECT EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5';


--관리하는 매니저가 있는 직원들 중에 직급이 J7이 아닌 사람들을 조회하시오
--WHERE
SELECT *
FROM EMPLOYEE
WHERE MANAGER_ID IS NOT NULL 
    AND JOB_CODE != 'J7';


--SET OPERATION(MINUS)
SELECT *
FROM EMPLOYEE
WHERE MANAGER_ID IS NOT NULL
MINUS
SELECT *
FROM EMPLOYEE
WHERE JOB_CODE = 'J7';


--GROUPING SET : 각각 그룹의 검색 결과를 합쳐서 출력
--19
SELECT DEPT_CODE, JOB_CODE, MANAGER_ID, TRUNC(AVG(SALARY))
FROM EMPLOYEE
GROUP BY DEPT_CODE, JOB_CODE, MANAGER_ID;
--15
SELECT DEPT_CODE, '잡코드 없음',  MANAGER_ID, TRUNC(AVG(SALARY))
FROM EMPLOYEE
GROUP BY DEPT_CODE, MANAGER_ID;
--19
SELECT '부서코드 없음', JOB_CODE, MANAGER_ID, TRUNC(AVG(SALARY))
FROM EMPLOYEE
GROUP BY JOB_CODE, MANAGER_ID;


SELECT DEPT_CODE, JOB_CODE, MANAGER_ID, TRUNC(AVG(SALARY))
FROM EMPLOYEE
GROUP BY GROUPING SETS((DEPT_CODE, JOB_CODE, MANAGER_ID),
                                                 (DEPT_CODE, MANAGER_ID),
                                                 (JOB_CODE, MANAGER_ID));


--JOIN : 다른 테이블의 정보를 같은 RESULT SET에 출력할때(한번에 출력하고자 할때)
--           사용한다. (테이블을 합친다)

SELECT *
FROM EMPLOYEE, DEPARTMENT
WHERE DEPT_CODE = DEPT_ID;


--오라클 구문(오라클에서만 사용가능하다)
SELECT EMP_ID, EMP_NAME, DEPT_TITLE, SALARY
FROM EMPLOYEE, DEPARTMENT
WHERE DEPT_CODE = DEPT_ID;

--ANSI표준 구문을 이용한 JOIN
SELECT EMP_ID, EMP_NAME, DEPT_TITLE, SALARY
FROM EMPLOYEE
JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID);


--사원 정보를 출력한다.
--사번, 이름, 직책명, 입사일
--오라클 전용 구문
SELECT EMPLOYEE.EMP_ID, EMPLOYEE.EMP_NAME, JOB.JOB_NAME, EMPLOYEE.HIRE_DATE
FROM EMPLOYEE, JOB
WHERE EMPLOYEE.JOB_CODE = JOB.JOB_CODE;


--안시표준
--ON 이용한 JOIN
SELECT EMP.EMP_ID, EMP.EMP_NAME, J.JOB_NAME, EMP.HIRE_DATE, JOB_CODE
FROM EMPLOYEE EMP 
JOIN JOB J ON (EMP.JOB_CODE = J.JOB_CODE);

--USING 이용한 JOIN
SELECT EMP.EMP_ID, EMP.EMP_NAME, J.JOB_NAME, EMP.HIRE_DATE, JOB_CODE
FROM EMPLOYEE EMP 
JOIN JOB J USING (JOB_CODE);


--'L4'의 지역 정보를 출력하려고 합니다.
--해당 지역의 영어 명, 국가코드, 국가명 
--안시표준
SELECT LOCAL_NAME, NATIONAL_CODE, NATIONAL_NAME
FROM LOCATION
JOIN NATIONAL USING(NATIONAL_CODE)
WHERE LOCAL_CODE = 'L4';

--오라클
--해당 지역의 영어 명, 국가코드, 국가명 
SELECT L.LOCAL_NAME, L.NATIONAL_CODE, N.NATIONAL_NAME 
FROM LOCATION L, NATIONAL N
WHERE L.NATIONAL_CODE = N.NATIONAL_CODE
    AND L.LOCAL_CODE = 'L4';
    

--INNER JOIN - 조인 조건의 값이 같을 경우만 조회 함
--OUTER JOIN - 조인조건의 데이터가 일부만 존재 할경우, 
--                      기준 테이블의 정보를 항상 포함하여 조회 할때 사용

--모든 직원의 정보를 출력하려고 한다. 
--직원명, 이메일, 전화번호, 부서명
--오라클 OUTER JOIN
SELECT E.EMP_NAME, E.EMAIL, E.PHONE, D.DEPT_TITLE
FROM EMPLOYEE E, DEPARTMENT D
WHERE E.DEPT_CODE = D.DEPT_ID(+);


--안시표준 아우터 조인
SELECT * 
FROM DEPARTMENT D
RIGHT JOIN EMPLOYEE E ON (E.DEPT_CODE = D.DEPT_ID);

SELECT * 
FROM EMPLOYEE E
LEFT JOIN DEPARTMENT D ON (E.DEPT_CODE = D.DEPT_ID);


--크로스 조인 : (카테이션 곱 AXB) 
--                  두 테이블을 합칠때 나올수 있는 모든 경우 항목을 출력
SELECT *
FROM LOCATION, NATIONAL;


SELECT *
FROM LOCATION
CROSS JOIN NATIONAL;

--NON-EQUI-JOIN : 값을 매핑시켜 조인하는 것이아닌, 
--                                조건식을 이용하여 JOIN 조건을 적용
--직원의 급여등급에 맞는 급여를 받고있는 직원의 정보만 출력하시오
--직원명, 급여등급, 현재급여, 해당급여등급의 최저급여/최고급여
--ANSI
SELECT E.EMP_NAME, E.SAL_LEVEL, E.SALARY, S.MIN_SAL || '/'|| S.MAX_SAL
FROM EMPLOYEE E
JOIN SAL_GRADE S ON (
E.SAL_LEVEL = S.SAL_LEVEL AND
E.SALARY BETWEEN S.MIN_SAL AND S.MAX_SAL);

--ORACLE
SELECT E.EMP_NAME, E.SAL_LEVEL, S.SAL_LEVEL, E.SALARY, S.MIN_SAL || '/'|| S.MAX_SAL
FROM EMPLOYEE E, SAL_GRADE S
WHERE E.SALARY BETWEEN S.MIN_SAL AND S.MAX_SAL;

--SELF JOIN : 같은 테이블끼리 조인을 하여 결과를 조회 함
--직원 정보를 출력하고 함
--직원 이름, 매니저 이름
--ORACLE
SELECT E1.EMP_NAME AS "직원 이름", E2.EMP_NAME AS "매니저 이름"
FROM EMPLOYEE E1, EMPLOYEE E2
WHERE E1.MANAGER_ID = E2.EMP_ID;

--ANSI
SELECT E1.EMP_NAME AS "직원 이름", E2.EMP_NAME AS "매니저 이름"
FROM EMPLOYEE E1
JOIN EMPLOYEE E2 ON (E1.MANAGER_ID = E2.EMP_ID);

--모든 직원 정보 조회
--직원명, 매니저 명
--ANSI 
SELECT E1.EMP_NAME AS "직원 이름", E2.EMP_NAME AS "매니저 이름"
FROM EMPLOYEE E1
LEFT JOIN EMPLOYEE E2 ON (E1.MANAGER_ID = E2.EMP_ID);




































































